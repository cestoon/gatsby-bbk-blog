---
title:  大规模数据集算法 - Integer Data Structures I：
date: "2023-05-05 14:14:26"
description:  算法- 学习笔记1 ： 字典、通用哈希和完美哈希
tags: ["算法", "数据结构", "学习笔记"]
---

  - [写在开头](#w1_intro)
  - [Hashing 哈希](#Hashing)
  - [Dictionaries problem 字典问题](#Dictionaries)
  - [Chained Hashing 链式哈希](#Chained-Hashing)
  - [Universal Hashing 通用哈希](#Universal-Hashing)
    - [举例子](#ex-number-systems)
  - [Static Dictionaries and Perfect Hashing 静态字典与完美哈希](#Static-Dictionaries-and-Perfect-Hashing)




<h2 id="w1_intro">写在开头</h2>

算法系列的自学笔记。

算法是用来解决问题的，也就是说，是先有客观实在的某种问题，再后来发展的算法。算法是抽象的，这种抽象性让它能匹配特定领域的问题，但其依然是存在于人脑中的符号系统。这套符号系统是处理复杂问题的思路，是一种思维的延伸。因为计算机的缘故，如今算法脱离了数学家哲学家思维游戏的范畴，生来就是为了优化空间与时间的复杂度，让计算机能更快更省的解决问题。

<h2 id="Hashing">Hashing 哈希</h2>

"Hash" 这个词原本是英语中的一个动词，意思是将食物切成小块或将物品搅拌混合。用在计算机科学中，"hash" 被引用为一个专有名词，表示一种用于将数据转换成函数。

它的典型问题就是字典

<h2 id="Dictionaries">Dictionaries problem 字典问题</h2>

联想中文字典，就是把一个字用拼音、部首或笔画定位到特定的字，这种编码本身就是一种函数。

对应到计算机科学中，字典是一种非常有用的数据结构。

它允许我们使用键值对存储和检索数据，其中每个键对应一个唯一的值。在字典中，键必须是唯一的，因为每个键都与一个值相关联。字典可以用于存储各种类型的数据，例如字符串、数字、对象等。

对于一个字典问题，要求有以下操作

- 查 lookup
- 增 insert
- 删 delete

字典域U会很大，而字典中的键数量S ≪ U(远远小于)

要求便是，实现紧密的(compact)数据结构和快速的操作，同时需要考虑到可能出现的哈希冲突，以确保字典的性能和正确性。

<h2 id="Chained-Hashing"> Chained Hashing 链式哈希</h2>

从链式哈希入手

![image-20230505144633347](./image-20230505144633347.png)

链式哈希：链式哈希是一种哈希表的实现方法，它使用链表来解决哈希冲突。

当两个不同的键被映射到相同的哈希桶时，它们被放入同一个链表中。这个链表被称为哈希槽或哈希桶。当我们需要查找特定键时，我们需要遍历该链表并比较每个键，直到找到匹配的键或链表的结尾。

We can store h in O(n) space. 

We can evaluate h in O(1) time

**如果哈希表中有许多冲突，那么链表可能会非常长，需要更多的空间来存储**。另外，链式哈希需要为每个哈希槽分配内存，因此它需要O(n)的总空间。时间上需要Time. O(1 + length of linked list for h(x))，取决于链表冲突的长度。

所以要想办法处理冲突，使用不同的哈希函数，然而选什么函数是有讲究的

比如，h(x) = x mod 10 这并不是一个很疯狂、混乱或随机的函数，很多数据会形成一个链表。最坏的情况下，甚至得到一个单链表。要解决这个问题，需要引入随机性。假定输入是随机的，那选择哈希函数也是随机的。如果函数h确实是“疯狂的”，“混沌的”和“随机的”，则使用h将使我们将S的元素随机分布在N个桶中。由于S的大小最多为N，我们应该期望桶通常很小。

定量计算一下：

![image-20230505151635028](./image-20230505151635028.png)

h(x) 是函数本身，E代表链表的长度,S是键值域。假设y $\in$ S，h(y) = h(x)。E的大小等于h(y) = h(x)数量的和。

换句话说，E等于h(y) = h(x)的概率和。假设有$m^{2}$个配对，m个冲突，那么链表长度E = 1+（n-1)· 1/m

总结一下，链式哈希

- 时间 O(1)
- 空间 O(n)

表现结果取决于哈希函数的选择，这个结果于输入集无关。

不过，上述的随机性是有问题的，由于哈希函数是从一个大的数据集合U到一个小的数据集合f1，…，Ng的映射，因此可能存在某些键的哈希值冲突，这可能导致桶的大小不均匀。选择随机函数的前提条件是不切实际的，因为在实践中，无法生成大到足以代表所有函数的函数集合，因此我们必须依赖于启发式的哈希函数，并根据它们的性能进行分析和改进

<h2 id="Universal-Hashing">Universal Hashing 通用哈希</h2>

通用哈希：**通用哈希是一种解决哈希冲突的方法**，通用哈希函数族的优点在于，它可以在任意输入数据的情况下提供良好的性能保证，而不需要事先了解输入数据的分布或结构。

在哈希表的上下文中，"universal"一词指的是一种哈希函数族，即从一定范围内随机选取一个哈希函数，使得每个键都被映射到哈希表上的槽中的概率相等

给定一个性质 (U) For all x != y; Pr[h(x) = h(y)]  !=N

N代表哈希表的槽数

即任意两个不同的键被映射到同一槽的概率不超过1/N。这是通用哈希的一个重要性质，确保了哈希表中的元素分布均匀，避免了冲突，使得哈希表的性能更好。

先给结论

在使用universal hashing解决动态字典问题时，当使用的哈希函数集合H是(nearly) universal family时，就可以做到空间复杂度为O(1)。

Universal Hashing 可以在以下情况下解决字典问题(没有特殊假设)：

- O(n)空间。 
- O(1)期望时间每个操作(查找、插入、删除)。

<h3 id="ex-number-systems">举例子</h3>

**Positional number systems 位置制数**

位置制数是一种数值表示方法，其中每个数字的意义由它在数中所占的位置决定。

- (10)10 = $(1010)_{2} (1⋅2^{3} + 0⋅2^{2} + 1⋅2^{1} + 0⋅2^{0} ) $

- $(107)_{10} = (212)_{7}(2⋅7^{2}+1⋅7^{1}+2⋅7^{0})$

十进制的10 可以换位二进制的1010，107换位七进制的211

位置制数的概念可以放进通用哈希

![image-20230505170158366](./image-20230505170158366.png)

取一个素数7，给一个范围a，x是输入范围，根据如图定义的哈希函数。$h_{a}(x)$，可以把424放入槽为4的桶中，同时保证了均匀性。a是从H这个哈希函数族中随机取的，这个过程构建很快。

除了以上的哈希函数，还有别的哈希函数，比如inverse

![image-20230505170717622](./image-20230505170717622.png)

假设m=7， 要求a•a-1 mod 7 =1，则对于a = {1...6}

<img src="./image-20230505171220679.png" alt="image-20230505171220679.png" style="zoom:50%;" />

回到定义，通用哈希希望冲突概率≤1/m

证明如下：

![image-20230505172149902](./image-20230505172149902.png)

<h2 id="Static-Dictionaries-and-Perfect-Hashing">Static Dictionaries and Perfect Hashing 静态字典与完美哈希</h2>

上面提到过的需要增删改的是动态字典，对于静态字典有完美哈希的解法。

**静态字典**：静态字典是一种特殊类型的字典，它的大小在创建后是固定的，不能更改。

我们希望先预处理一下，实现查找功能O(1)实现

**完美哈希**：完美哈希是一种解决哈希冲突的技术，它可以实现在静态字典中快速查找。完美哈希使用一种特殊的哈希函数，该函数可以将每个键映射到一个唯一的哈希值，而不需要解决哈希冲突。这样，我们可以在常数时间内查找特定键，因为每个键都对应唯一的位置。完美哈希可以在静态字典中实现快速查找，但是它需要额外的计算来生成哈希函数，并且如果字典的大小发生变化，则必须重新生成哈希函数。



分三步来解决这个问题：

1. **Solution 1**: Collision-free but with too much space. 无冲突但空间使用过多

   具体思路是

   - 使用一个通用哈希函数将元素映射到大小为n^2的数组中。有50%的概率获得完美的哈希函数。如果没有完美的哈希函数，则重试。
   - ⟹ 在获得完美哈希函数之前，期望的尝试次数是O(1)。
   - ⟹ 对于静态集合S，我们可以使用O(n^2)的空间支持O(1)的最坏情况查找时间

2. Solution2: 许多碰撞但线性空间

   具体思路就是把1的空间换成n

3. Solution 3. Two-level solution. 两层模式  FKS scheme
   ![image-20230505174354272](./image-20230505174354272.png)

   在第1级使用有很多冲突和线性空间的解决方案。

   在第1级解决每个冲突，采用第2级无冲突解决方案

   查找(x)：在第1级查找以找到正确的第2级字典。在第2级字典中查找

   可以实现O(n) space and O(n) 的预处理时间.


### references
> http://courses.compute.dtu.dk/02282/2023/hashing/universalhashing.pdf
> http://courses.csail.mit.edu/6.851/spring07/scribe/lec11.pdf